{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nimport { inputTags, textInputTypes } from './enums';\nimport activeElement from './active_element'; // Indicates if the passed element is considered a text input.\n//\n\nvar isTextInput = function isTextInput(element) {\n  return inputTags[element.tagName] && textInputTypes[element.type];\n}; // Assigns focus to the appropriate element... preferring the explicitly passed selector\n//\n// * selector - a CSS selector for the element that should have focus\n//\n\n\nvar assignFocus = function assignFocus(selector) {\n  var element = selector && selector.nodeType === Node.ELEMENT_NODE ? selector : document.querySelector(selector);\n  var focusElement = element || activeElement.element;\n  if (focusElement && focusElement.focus) focusElement.focus();\n}; // Dispatches an event on the passed element\n//\n// * element - the element\n// * name - the name of the event\n// * detail - the event detail\n//\n\n\nvar dispatch = function dispatch(element, name) {\n  var detail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var init = {\n    bubbles: true,\n    cancelable: true,\n    detail: detail\n  };\n  var evt = new CustomEvent(name, init);\n  element.dispatchEvent(evt);\n  if (window.jQuery) window.jQuery(element).trigger(name, detail);\n}; // Accepts an xPath query and returns the element found at that position in the DOM\n//\n\n\nvar xpathToElement = function xpathToElement(xpath) {\n  return document.evaluate(xpath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;\n}; // Return an array with the class names to be used\n//\n// * names - could be a string or an array of strings for multiple classes.\n//\n\n\nvar getClassNames = function getClassNames(names) {\n  return Array(names).flat();\n}; // Perform operation for either the first or all of the elements returned by CSS selector\n//\n// * operation - the instruction payload from perform\n// * callback - the operation function to run for each element\n//\n\n\nvar processElements = function processElements(operation, callback) {\n  Array.from(operation.selectAll ? operation.element : [operation.element]).forEach(callback);\n}; // camelCase to kebab-case\n//\n\n\nvar kebabize = function kebabize(str) {\n  return str.split('').map(function (letter, idx) {\n    return letter.toUpperCase() === letter ? \"\".concat(idx !== 0 ? '-' : '').concat(letter.toLowerCase()) : letter;\n  }).join('');\n}; // Provide a standardized pipeline of checks and modifications to all operations based on provided options\n// Currently skips execution if cancelled and implements an optional delay\n//\n\n\nvar operate = function operate(operation, callback) {\n  if (!operation.cancel) {\n    operation.delay ? setTimeout(callback, operation.delay) : callback();\n    return true;\n  }\n\n  return false;\n}; // Dispatch life-cycle events with standardized naming\n\n\nvar before = function before(target, operation) {\n  return dispatch(target, \"cable-ready:before-\".concat(kebabize(operation.operation)), operation);\n};\n\nvar after = function after(target, operation) {\n  return dispatch(target, \"cable-ready:after-\".concat(kebabize(operation.operation)), operation);\n};\n\nfunction debounce(func, timeout) {\n  var _this = this;\n\n  var timer;\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    clearTimeout(timer);\n    timer = setTimeout(function () {\n      return func.apply(_this, args);\n    }, timeout);\n  };\n}\n\nfunction handleErrors(response) {\n  if (!response.ok) throw Error(response.statusText);\n  return response;\n} // A proxy method to wrap a fetch call in error handling\n//\n// * url - the URL to fetch\n// * additionalHeaders - an object of additional headers passed to fetch\n//\n\n\nfunction graciouslyFetch(_x, _x2) {\n  return _graciouslyFetch.apply(this, arguments);\n}\n\nfunction _graciouslyFetch() {\n  _graciouslyFetch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(url, additionalHeaders) {\n    var response;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.prev = 0;\n            _context.next = 3;\n            return fetch(url, {\n              headers: _objectSpread({\n                'X-REQUESTED-WITH': 'XmlHttpRequest'\n              }, additionalHeaders)\n            });\n\n          case 3:\n            response = _context.sent;\n\n            if (!(response == undefined)) {\n              _context.next = 6;\n              break;\n            }\n\n            return _context.abrupt(\"return\");\n\n          case 6:\n            handleErrors(response);\n            return _context.abrupt(\"return\", response);\n\n          case 10:\n            _context.prev = 10;\n            _context.t0 = _context[\"catch\"](0);\n            console.error(\"Could not fetch \".concat(url));\n\n          case 13:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[0, 10]]);\n  }));\n  return _graciouslyFetch.apply(this, arguments);\n}\n\nexport { isTextInput, assignFocus, dispatch, xpathToElement, getClassNames, processElements, operate, before, after, debounce, handleErrors, graciouslyFetch };","map":null,"metadata":{},"sourceType":"module"}